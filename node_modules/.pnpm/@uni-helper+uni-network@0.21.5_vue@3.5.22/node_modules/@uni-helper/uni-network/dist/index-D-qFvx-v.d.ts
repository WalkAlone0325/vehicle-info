//#region src/types/common.d.ts
type UnData = string | Record<string, any> | ArrayBuffer;
type UnMethod = "get" | "GET" | "delete" | "DELETE" | "head" | "HEAD" | "options" | "OPTIONS" | "post" | "POST" | "put" | "PUT" | "patch" | "PATCH" | "trace" | "TRACE" | "connect" | "CONNECT";
type UnHeaders = Record<string, any>;
type UnParams = Record<string, any>;
type UnParamsSerializer = (params?: UnParams) => string;
type UnValidateStatus = (status: number) => boolean | null;
interface UnGenericAbortSignal {
  readonly aborted: boolean;
  onabort?: ((...args: any) => any) | null;
  addEventListener?: (...args: any) => any;
  removeEventListener?: (...args: any) => any;
}
type UnDataType = "json" | string;
type UnResponseType = "text" | "arraybuffer";
interface UnFile {
  name?: string;
  file?: File;
  uri?: string;
}
type UnOnProgress = (response?: {
  /** 当前上传/下载百分比 */
  progress?: number;
  /** 已经上传的数据长度，单位 Bytes */
  totalBytesSent?: number;
  /** 预期需要上传的数据总长度，单位 Bytes */
  totalBytesExpectedToSend?: number;
  /** 已经下载的数据长度，单位 Bytes */
  totalBytesWritten?: number;
  /** 预期需要下载的数据总长度，单位 Bytes */
  totalBytesExpectedToWrite?: number;
}) => void;
type UnFileType = "image" | "video" | "audio";
interface UnProfile {
  /**
   * 第一个 HTTP 重定向发生时的时间
   *
   * 有跳转且是同域名内的重定向才算，否则值为 0
   */
  redirectStart?: number;
  /**
   * 最后一个 HTTP 重定向完成时的时间
   *
   * 有跳转且是同域名内部的重定向才算，否则值为 0
   */
  redirectEnd?: number;
  /** 组件准备好使用 HTTP 请求抓取资源的时间，这发生在检查本地缓存之前 */
  fetchStart?: number;
  /**
   * DNS 域名查询开始的时间
   *
   * 如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
   */
  domainLookupStart?: number;
  /**
   * DNS 域名查询完成的时间
   *
   * 如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
   */
  domainLookupEnd?: number;
  /**
   * HTTP（TCP） 开始建立连接的时间
   *
   * 如果是持久连接，则与 fetchStart 值相等
   *
   * 如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间
   */
  connectStart?: number;
  /**
   * HTTP（TCP） 完成建立连接的时间（完成握手）
   *
   * 如果是持久连接，则与 fetchStart 值相等
   *
   * 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间
   *
   * 这里的完成握手包括安全连接建立完成、SOCKS 授权通过
   */
  connectEnd?: number;
  /**
   * SSL建立连接的时间
   *
   * 如果不是安全连接，则值为 0
   */
  SSLconnectionStart?: number;
  /**
   * SSL 建立完成的时间
   *
   * 如果不是安全连接，则值为 0
   */
  SSLconnectionEnd?: number;
  /**
   * HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存
   *
   * 连接错误重连时，这里显示的也是新建立连接的时间
   */
  requestStart?: number;
  /** HTTP 请求读取真实文档结束的时间 */
  requestEnd?: number;
  /** HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存 */
  responseStart?: number;
  /** HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存 */
  responseEnd?: number;
  /** 当次请求连接过程中实时 rtt */
  rtt?: number;
  /** 评估的网络状态 */
  estimate_nettype?: string | number;
  /** 协议层根据多个请求评估当前网络的 rtt（仅供参考） */
  httpRttEstimate?: number;
  /** 传输层根据多个请求评估的当前网络的 rtt（仅供参考） */
  transportRttEstimate?: number;
  /** 评估当前网络下载的 kbps */
  downstreamThroughputKbpsEstimate?: number;
  /** 当前网络的实际下载 kbps */
  throughputKbps?: number;
  /** 当前请求的 IP */
  peerIP?: string;
  /** 当前请求的端口 */
  port?: number;
  /** 是否复用连接 */
  socketReused?: boolean;
  /** 发送的字节数 */
  sendBytesCount?: number;
  /** 收到字节数 */
  receivedBytedCount?: number;
  /** 使用协议类型 */
  protocol?: "http1.1" | "h2" | "quic" | "unknown" | string;
}
//#endregion
//#region src/core/UnCancelToken.d.ts
interface UnCancel {
  message?: string;
}
interface UnCancelStatic {
  new (message?: string): UnCancel;
}
type UnCanceler<T = UnData, D = UnData> = (message?: string, config?: UnConfig<T, D>, task?: UnTask) => void;
type UnCancelTokenListener = (reason: UnCancel | PromiseLike<UnCancel>) => void;
interface UnCancelTokenSource<T = UnData, D = UnData> {
  token: UnCancelToken;
  cancel: UnCanceler<T, D>;
}
interface UnCancelTokenStatic<T = UnData, D = UnData> {
  new (executor: (cancel: UnCanceler) => void): UnCancelToken;
  source: () => UnCancelTokenSource<T, D>;
}
declare class UnCancelToken<T = UnData, D = UnData> {
  promise: Promise<UnCancel>;
  reason?: UnCancel;
  private listeners;
  constructor(executor: (cancel: UnCanceler<T, D>) => void);
  throwIfRequested(): void;
  subscribe(listener: UnCancelTokenListener): void;
  unsubscribe(listener: UnCancelTokenListener): void;
  toAbortSignal(): AbortSignal & {
    unsubscribe: () => void;
  };
  static source<TT = UnData, DD = UnData>(): UnCancelTokenSource<TT, DD>;
}
//#endregion
//#region src/types/config.d.ts
interface UnConfig<T = UnData, D = UnData> {
  /** 用于请求的服务器 URL */
  url?: string;
  /**
   * 创建请求时使用的方法
   *
   * 默认为 'GET'
   */
  method?: UnMethod;
  /** 自动加在 `url` 前面，除非 `url` 是一个绝对 URL 且选项 `allowAbsoluteUrls` 为 true */
  baseUrl?: string;
  /**
   * 决定是否允许绝对 URL 覆盖配置的 `baseUrl`
   *
   * 当设置为 true（默认）时，绝对值的 `url` 会覆盖 `baseUrl`
   *
   * 当设置为 false 时，绝对值的 `url` 会始终被 `baseUrl` 前置
   */
  allowAbsoluteUrls?: boolean;
  /** 自定义请求头，不能设置 Referer */
  headers?: UnHeaders;
  /** 与请求一起发送的 URL 参数 */
  params?: UnParams;
  /**
   * 可选方法，主要用于序列化 `params`
   *
   * 默认使用 [fast-querystring](https://github.com/anonrig/fast-querystring)
   * 序列化，需要自行处理嵌套值
   *
   * [picoquery](https://github.com/43081j/picoquery) 在 fast-querystring
   * 基础上支持嵌套值、增加可配置性
   *
   * [qs](https://github.com/ljharb/qs) 包含大量无用的兼容代码，占用额外体积，如无必要不建议使用
   *
   * [qs](https://github.com/ljharb/qs) v6.10.0 引入了 `get-intrinsic`
   * 导致结合微信小程序和微信小程序插件使用时出现报错，可使用 v6.9.7
   *
   * [query-string](https://github.com/sindresorhus/query-string) 体积性能都较好，支持完善
   *
   * [query-string](https://github.com/sindresorhus/query-string) 基于
   * [decode-uri-component](https://github.com/SamVerschueren/decode-uri-component)，它使用了部分小程序（如支付宝小程序）不支持的语法（可选的
   * catch 参数，Optional catch Binding），需自行修改处理
   */
  paramsSerializer?: UnParamsSerializer;
  /**
   * 作为请求体被发送的数据
   *
   * 必须是以下类型之一：string、ArrayBuffer、Record<string, any>
   */
  data?: D;
  /**
   * 指定请求超时的毫秒数
   *
   * 如果请求时间超过 `timeout` 的值，则请求会被中断
   *
   * 要设置永不超时，可以将其设置为 Number.POSITIVE_INFINITY
   *
   * 默认值是实际调用的 API 的默认值
   */
  timeout?: number;
  /**
   * 允许自定义处理请求
   *
   * 可以指定为 'request'、`upload` 和 `download` 三者之一
   *
   * 也可以指定为一个方法，返回一个 Promise 并提供一个有效的响应
   *
   * 如果你正在使用 un.request、un.download、un.upload、un.get 等别名方法，则无需再指定该键的值
   *
   * 默认为 'request'
   */
  adapter?: "request" | "download" | "upload" | UnAdapter<T, D>;
  /**
   * 定义了对于给定的 HTTP 状态码该 resolve 还是 reject
   *
   * 如果 `validateStatus` 返回 `true`、`null` 或 `undefined`
   *
   * 则 promise 将会被 resolve，否则会被 reject
   *
   * 默认为 (status) => status >= 200 && status < 300
   */
  validateStatus?: UnValidateStatus;
  /** 用于取消请求 */
  signal?: UnGenericAbortSignal;
  /** 用于取消请求 */
  cancelToken?: UnCancelToken<T, D>;
  /**
   * 监听 HTTP Response Header 事件
   *
   * 会比请求完成事件更早
   */
  onHeadersReceived?: (response?: {
    headers?: UnHeaders;
  }) => void;
  /**
   * Request 使用
   *
   * 服务器返回数据的类型
   *
   * 如果设置为 json，会尝试对返回的数据做一次 JSON.parse
   *
   * 默认为 json
   */
  dataType?: UnDataType;
  /**
   * Request 使用
   *
   * 响应的数据类型
   *
   * 默认为 text
   */
  responseType?: UnResponseType;
  /**
   * Request 使用
   *
   * 是否开启 http2
   *
   * 默认为 false
   */
  enableHttp2?: boolean;
  /**
   * Request 使用
   *
   * 是否开启 quic
   *
   * 默认为 false
   */
  enableQuic?: boolean;
  /**
   * Request 使用
   *
   * 是否开启缓存
   *
   * 默认为 false
   */
  enableCache?: boolean;
  /**
   * Request 使用
   *
   * 是否开启 HttpDNS 服务
   *
   * 默认为 false
   */
  enableHttpDNS?: boolean;
  /**
   * Request 使用
   *
   * HttpDNS 服务商 Id
   */
  httpDNSServiceId?: string;
  /**
   * Request 使用
   *
   * 是否开启 transfer-encoding chunked
   *
   * 默认为 false
   */
  enableChunked?: boolean;
  /**
   * Request 使用
   *
   * 是否在 wifi 下使用移动网络发送请求
   *
   * 默认为 false
   */
  forceCellularNetwork?: boolean;
  /**
   * Request 使用
   *
   * 是否验证 ssl 证书
   *
   * 默认为 true
   */
  sslVerify?: boolean;
  /**
   * Request 使用
   *
   * 跨域请求时是否需要使用凭证
   *
   * 默认为 false
   */
  withCredentials?: boolean;
  /**
   * Request 使用
   *
   * 是否在 DNS 解析时优先使用 ipv4
   *
   * 默认为 false
   */
  firstIpv4?: boolean;
  /**
   * Request 使用
   *
   * 监听 Transfer-Encoding Chunk Received 事件
   *
   * 当接收到新的 chunk 时触发
   */
  onChunkReceived?: (response?: {
    data?: ArrayBuffer;
  }) => void;
  /**
   * Upload 使用
   *
   * 需要上传的文件列表，files 和 filePath 必填一个
   *
   * 使用该参数时，filePath 和 name 无效
   *
   * 不支持小程序
   */
  files?: UnFile[];
  /**
   * Upload 使用
   *
   * 文件类型
   */
  fileType?: UnFileType;
  /**
   * Upload 使用
   *
   * 文件对象
   */
  file?: File;
  /**
   * Upload 使用
   *
   * 文件路径，files 和 filePath 必填一个
   *
   * Download 使用
   *
   * 文件下载后存储的本地路径
   */
  filePath?: string;
  /**
   * Upload 使用
   *
   * 文件对应的 key , 开发者在服务器端通过这个 key 可以获取到文件二进制内容
   */
  name?: string;
  /**
   * Upload 使用
   *
   * 一个对象，会作为 HTTP 请求中其它额外的 form data
   */
  formData?: Record<string, any>;
  /**
   * Download 使用
   *
   * 下载进度变化时触发
   *
   * 优先级 onDownloadProgress > onDownloadProgressUpdate > onProgress >
   * onProgressUpdate
   */
  onDownloadProgress?: UnOnProgress;
  /**
   * Download 使用
   *
   * 下载进度变化时触发
   *
   * 优先级 onDownloadProgress > onDownloadProgressUpdate > onProgress >
   * onProgressUpdate
   */
  onDownloadProgressUpdate?: UnOnProgress;
  /**
   * Upload 使用
   *
   * 上传进度变化时触发
   *
   * 优先级 onUploadProgress > onUploadProgressUpdate > onProgress >
   * onProgressUpdate
   */
  onUploadProgress?: UnOnProgress;
  /**
   * Upload 使用
   *
   * 上传进度变化时触发
   *
   * 优先级 onUploadProgress > onUploadProgressUpdate > onProgress >
   * onProgressUpdate
   */
  onUploadProgressUpdate?: UnOnProgress;
  /**
   * Upload / download 使用
   *
   * 上传/下载进度变化时触发
   *
   * 优先级 onUploadProgress / onDownloadProgress > onUploadProgressUpdate /
   * onDownloadProgressUpdate > onProgress > onProgressUpdate
   */
  onProgress?: UnOnProgress;
  /**
   * Upload / download 使用
   *
   * 上传/下载进度变化时触发
   *
   * 优先级 onUploadProgress / onDownloadProgress > onUploadProgressUpdate /
   * onDownloadProgressUpdate > onProgress > onProgressUpdate
   */
  onProgressUpdate?: UnOnProgress;
  [key: string]: any;
}
//#endregion
//#region src/types/task.d.ts
interface UnTask extends Partial<UniApp.RequestTask>, Partial<Omit<UniApp.DownloadTask, "onProgressUpdate">>, Partial<Omit<UniApp.UploadTask, "onProgressUpdate">> {
  onProgressUpdate?: (callback: UnOnProgress) => void;
  [key: string]: any;
}
//#endregion
//#region src/types/response.d.ts
interface UnResponse<T = UnData, D = UnData> {
  /** 错误信息 */
  errMsg?: string;
  /** 错误代码 */
  errno?: number;
  /** 网络请求过程中的调试信息 */
  profile?: UnProfile;
  /** 请求的配置信息 */
  config?: UnConfig<T, D>;
  /** 对应的 task 信息 */
  task?: UnTask;
  /** 服务器响应的 HTTP 状态码 */
  status?: number;
  /** 服务器响应的 HTTP 状态信息 */
  statusText?: string;
  /** 服务器响应头 */
  headers?: UnHeaders;
  /** 服务器响应数据 */
  data?: T;
  /**
   * Request 特有
   *
   * 服务器提供的 cookies 数据
   */
  cookies?: string[];
  /**
   * Download 特有
   *
   * 临时本地文件路径
   *
   * 没传入 filePath 指定文件存储路径时会返回，下载后的文件会存储到一个临时文件
   */
  tempFilePath?: string;
  /**
   * Download 特有
   *
   * 用户本地文件路径
   *
   * 传入 filePath 时会返回，跟传入的 filePath 一致
   */
  filePath?: string;
}
//#endregion
//#region src/types/promise.d.ts
type UnPromise<T = UnData, D = UnData> = Promise<UnResponse<T, D>>;
//#endregion
//#region src/types/adapter.d.ts
type UnAdapter<T = UnData, D = UnData> = (config: UnConfig<T, D>) => UnPromise<T, D>;
//#endregion
//#region src/core/dispatchRequest.d.ts
declare const dispatchRequest: <T = UnData, D = UnData>(config: UnConfig<T, D>) => Promise<UnResponse<T, D>>;
//#endregion
//#region src/core/HttpStatusCode.d.ts
declare const HttpStatusCode: {
  readonly Continue: 100;
  readonly 100: "Continue";
  readonly SwitchingProtocols: 101;
  readonly 101: "SwitchingProtocols";
  readonly Processing: 102;
  readonly 102: "Processing";
  readonly EarlyHints: 103;
  readonly 103: "EarlyHints";
  readonly Ok: 200;
  readonly 200: "Ok";
  readonly Created: 201;
  readonly 201: "Created";
  readonly Accepted: 202;
  readonly 202: "Accepted";
  readonly NonAuthoritativeInformation: 203;
  readonly 203: "NonAuthoritativeInformation";
  readonly NoContent: 204;
  readonly 204: "NoContent";
  readonly ResetContent: 205;
  readonly 205: "ResetContent";
  readonly PartialContent: 206;
  readonly 206: "PartialContent";
  readonly MultiStatus: 207;
  readonly 207: "MultiStatus";
  readonly AlreadyReported: 208;
  readonly 208: "AlreadyReported";
  readonly ImUsed: 226;
  readonly 226: "ImUsed";
  readonly MultipleChoices: 300;
  readonly 300: "MultipleChoices";
  readonly MovedPermanently: 301;
  readonly 301: "MovedPermanently";
  readonly Found: 302;
  readonly 302: "Found";
  readonly SeeOther: 303;
  readonly 303: "SeeOther";
  readonly NotModified: 304;
  readonly 304: "NotModified";
  readonly UseProxy: 305;
  readonly 305: "UseProxy";
  readonly Unused: 306;
  readonly 306: "Unused";
  readonly TemporaryRedirect: 307;
  readonly 307: "TemporaryRedirect";
  readonly PermanentRedirect: 308;
  readonly 308: "PermanentRedirect";
  readonly BadRequest: 400;
  readonly 400: "BadRequest";
  readonly Unauthorized: 401;
  readonly 401: "Unauthorized";
  readonly PaymentRequired: 402;
  readonly 402: "PaymentRequired";
  readonly Forbidden: 403;
  readonly 403: "Forbidden";
  readonly NotFound: 404;
  readonly 404: "NotFound";
  readonly MethodNotAllowed: 405;
  readonly 405: "MethodNotAllowed";
  readonly NotAcceptable: 406;
  readonly 406: "NotAcceptable";
  readonly ProxyAuthenticationRequired: 407;
  readonly 407: "ProxyAuthenticationRequired";
  readonly RequestTimeout: 408;
  readonly 408: "RequestTimeout";
  readonly Conflict: 409;
  readonly 409: "Conflict";
  readonly Gone: 410;
  readonly 410: "Gone";
  readonly LengthRequired: 411;
  readonly 411: "LengthRequired";
  readonly PreconditionFailed: 412;
  readonly 412: "PreconditionFailed";
  readonly PayloadTooLarge: 413;
  readonly 413: "PayloadTooLarge";
  readonly UriTooLong: 414;
  readonly 414: "UriTooLong";
  readonly UnsupportedMediaType: 415;
  readonly 415: "UnsupportedMediaType";
  readonly RangeNotSatisfiable: 416;
  readonly 416: "RangeNotSatisfiable";
  readonly ExpectationFailed: 417;
  readonly 417: "ExpectationFailed";
  readonly ImATeapot: 418;
  readonly 418: "ImATeapot";
  readonly MisdirectedRequest: 421;
  readonly 421: "MisdirectedRequest";
  readonly UnprocessableEntity: 422;
  readonly 422: "UnprocessableEntity";
  readonly Locked: 423;
  readonly 423: "Locked";
  readonly FailedDependency: 424;
  readonly 424: "FailedDependency";
  readonly TooEarly: 425;
  readonly 425: "TooEarly";
  readonly UpgradeRequired: 426;
  readonly 426: "UpgradeRequired";
  readonly PreconditionRequired: 428;
  readonly 428: "PreconditionRequired";
  readonly TooManyRequests: 429;
  readonly 429: "TooManyRequests";
  readonly RequestHeaderFieldsTooLarge: 431;
  readonly 431: "RequestHeaderFieldsTooLarge";
  readonly UnavailableForLegalReasons: 451;
  readonly 451: "UnavailableForLegalReasons";
  readonly InternalServerError: 500;
  readonly 500: "InternalServerError";
  readonly NotImplemented: 501;
  readonly 501: "NotImplemented";
  readonly BadGateway: 502;
  readonly 502: "BadGateway";
  readonly ServiceUnavailable: 503;
  readonly 503: "ServiceUnavailable";
  readonly GatewayTimeout: 504;
  readonly 504: "GatewayTimeout";
  readonly HttpVersionNotSupported: 505;
  readonly 505: "HttpVersionNotSupported";
  readonly VariantAlsoNegotiates: 506;
  readonly 506: "VariantAlsoNegotiates";
  readonly InsufficientStorage: 507;
  readonly 507: "InsufficientStorage";
  readonly LoopDetected: 508;
  readonly 508: "LoopDetected";
  readonly NotExtended: 510;
  readonly 510: "NotExtended";
  readonly NetworkAuthenticationRequired: 511;
  readonly 511: "NetworkAuthenticationRequired";
};
//#endregion
//#region src/core/isUnCancel.d.ts
declare const isUnCancel: (value: any) => value is UnCancel;
//#endregion
//#region src/core/UnError.d.ts
declare class UnError<T = UnData, D = UnData> extends Error {
  static ERR_FR_TOO_MANY_REDIRECTS: string;
  static ERR_BAD_OPTION_VALUE: string;
  static ERR_BAD_OPTION: string;
  static ERR_NETWORK: string;
  static ERR_DEPRECATED: string;
  static ERR_BAD_RESPONSE: string;
  static ERR_BAD_REQUEST: string;
  static ERR_NOT_SUPPORT: string;
  static ERR_INVALID_URL: string;
  static ERR_CANCELED: string;
  static ECONNABORTED: string;
  static ETIMEDOUT: string;
  code?: string;
  config?: UnConfig<T, D>;
  task?: UnTask;
  response?: UnResponse<T, D>;
  isUnError: boolean;
  status?: number;
  cause?: Error;
  constructor(message?: string, code?: string, config?: UnConfig<T, D>, task?: UnTask, response?: UnResponse<T, D>);
  toJSON(): {
    name: string;
    message?: string;
    stack?: string;
    config?: UnConfig<T, D>;
    code?: string;
    status?: number;
    [key: string]: any;
  };
  static from<TT = UnData, DD = UnData>(error?: Error, code?: string, config?: UnConfig<TT, DD>, task?: UnTask, response?: UnResponse<TT, DD>, customProps?: Record<string, any>): UnError<TT, DD>;
}
//#endregion
//#region src/core/isUnError.d.ts
declare const isUnError: <T = UnData, D = UnData>(value: any) => value is UnError<T, D>;
//#endregion
//#region src/core/settle.d.ts
declare const settle: <T = UnData, D = UnData, R extends UnResponse<T, D> = UnResponse<T, D>>(resolve: (value: R | PromiseLike<R>) => void, reject: (reason?: any) => void, response: R) => void;
//#endregion
//#region src/core/UnInterceptorManager.d.ts
interface UnInterceptorOptions<T = UnData, D = UnData> {
  synchronous?: boolean;
  runWhen?: (config: UnConfig<T, D>) => boolean;
}
type UnInterceptorManagerHandlerFulfilled<V> = (value: V) => V | Promise<V>;
type UnInterceptorManagerHandlerRejected = (error: any) => any;
interface UnInterceptorManagerHandler<V, T = V, D = UnData> extends UnInterceptorOptions<T, D> {
  fulfilled?: UnInterceptorManagerHandlerFulfilled<V>;
  rejected?: UnInterceptorManagerHandlerRejected;
}
declare class UnInterceptorManager<V, T = V, D = UnData> {
  private handlers;
  use(fulfilled?: UnInterceptorManagerHandlerFulfilled<V>, rejected?: UnInterceptorManagerHandlerRejected, options?: UnInterceptorOptions<T, D>): number;
  eject(id: number): void;
  clear(): void;
  each(fn: (handler: UnInterceptorManagerHandler<V, T, D>) => any): void;
}
//#endregion
//#region src/core/Un.d.ts
declare class Un<T = UnData, D = UnData> {
  defaults: UnConfig<T, D>;
  interceptors: {
    request: UnInterceptorManager<UnConfig<T, D>, T, D>;
    response: UnInterceptorManager<UnResponse<T, D>, T, D>;
  };
  constructor(instanceConfig?: UnConfig<T, D>);
  private _request;
  request<TT = T, DD = D, R = UnResponse<TT, DD>>(configOrUrl: string | UnConfig<TT, DD>, config?: UnConfig<TT, DD>): Promise<R>;
  download<TT = T, DD = D, R = UnResponse<TT, DD>>(configOrUrl: string | UnConfig<TT, DD>, config?: UnConfig<TT, DD>): Promise<R>;
  upload<TT = T, DD = D, R = UnResponse<TT, DD>>(configOrUrl: string | UnConfig<TT, DD>, config?: UnConfig<TT, DD>): Promise<R>;
  get<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, config?: UnConfig<TT, DD>): Promise<R>;
  delete<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, config?: UnConfig<TT, DD>): Promise<R>;
  head<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, config?: UnConfig<TT, DD>): Promise<R>;
  options<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, config?: UnConfig<TT, DD>): Promise<R>;
  trace<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, config?: UnConfig<TT, DD>): Promise<R>;
  connect<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, config?: UnConfig<TT, DD>): Promise<R>;
  post<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, data?: DD, config?: UnConfig<TT, DD>): Promise<R>;
  put<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, data?: DD, config?: UnConfig<TT, DD>): Promise<R>;
  patch<TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, data?: DD, config?: UnConfig<TT, DD>): Promise<R>;
  getUri(config: UnConfig<T, D>): string;
}
//#endregion
//#region src/core/UnCanceledError.d.ts
declare class UnCanceledError<T = UnData, D = UnData> extends UnError<T, D> {
  isUnCanceledError: boolean;
  constructor(message?: string, config?: UnConfig<T, D>, task?: UnTask);
}
//#endregion
//#region src/utils/buildDownloadConfig.d.ts
declare const buildDownloadConfig: <T = UnData, D = UnData>(config: UnConfig<T, D>) => UniApp.DownloadFileOption;
//#endregion
//#region src/utils/buildFullPath.d.ts
declare const buildFullPath: (baseUrl: string, requestedUrl: string, allowAbsoluteUrls: boolean) => string;
//#endregion
//#region src/utils/buildRequestConfig.d.ts
declare const buildRequestConfig: <T = UnData, D = UnData>(config: UnConfig<T, D>) => UniApp.RequestOptions;
//#endregion
//#region src/utils/buildUploadConfig.d.ts
declare const buildUploadConfig: <T = UnData, D = UnData>(config: UnConfig<T, D>) => UniApp.UploadFileOption;
//#endregion
//#region src/utils/buildUrl.d.ts
declare const buildUrl: (url: string, params?: UnParams, paramsSerializer?: UnParamsSerializer) => string;
//#endregion
//#region src/utils/combineUrls.d.ts
declare const combineUrls: (baseUrl: string, relativeUrl: string) => string;
//#endregion
//#region src/utils/extend.d.ts
/**
 * 向对象 a 添加对象 b 的属性
 *
 * 直接改变对象 a
 */
declare const extend: (a: Record<string, any>, b: Record<string, any>, thisArg?: Record<string, any> | null | undefined, {
  allOwnKeys
}?: {
  allOwnKeys?: boolean | undefined;
}) => Record<string, any>;
//#endregion
//#region src/utils/forEach.d.ts
/**
 * 遍历数组或对象，为每项调用方法
 *
 * 如果 obj 是一个数组，传递每项的值、索引和完整的数组
 *
 * 如果 obj 是一个对象，为每个属性传递值、键和完整的对象
 */
declare function forEach(obj: Record<string, any> | Array<any> | undefined, fn: (...rest: any) => any, {
  allOwnKeys
}?: {
  allOwnKeys?: boolean | undefined;
}): void;
//#endregion
//#region src/utils/isAbsoluteUrl.d.ts
declare const isAbsoluteUrl: (url: string) => boolean;
//#endregion
//#region src/utils/mergeConfig.d.ts
declare function mergeConfig<T = UnData, D = UnData>(config1?: UnConfig<T, D>, config2?: UnConfig<T, D>): UnConfig<T, D>;
//#endregion
//#region src/adapters/download.d.ts
declare const downloadAdapter: <T = UnData, D = UnData>(config: UnConfig<T, D>) => Promise<UnResponse<T, D>>;
//#endregion
//#region src/adapters/request.d.ts
declare const requestAdapter: <T = UnData, D = UnData>(config: UnConfig<T, D>) => Promise<UnResponse<T, D>>;
//#endregion
//#region src/adapters/upload.d.ts
declare const uploadAdapter: <T = UnData, D = UnData>(config: UnConfig<T, D>) => Promise<UnResponse<T, D>>;
//#endregion
//#region src/adapters/index.d.ts
declare const adapters: {
  download: <T = UnData, D = UnData>(config: UnConfig<T, D>) => Promise<UnResponse<T, D>>;
  request: <T = UnData, D = UnData>(config: UnConfig<T, D>) => Promise<UnResponse<T, D>>;
  upload: <T = UnData, D = UnData>(config: UnConfig<T, D>) => Promise<UnResponse<T, D>>;
};
//#endregion
//#region src/defaults/index.d.ts
declare const defaults: Partial<UnConfig>;
//#endregion
//#region src/index.d.ts
interface UnInstance<T = UnData, D = UnData> extends Un<T, D> {
  <TT = T, DD = D, R = UnResponse<TT, DD>>(config: UnConfig<TT, DD>): Promise<R>;
  <TT = T, DD = D, R = UnResponse<TT, DD>>(url: string, config?: UnConfig<TT, DD>): Promise<R>;
  defaults: UnConfig<T, D>;
}
interface UnStatic<T = UnData, D = UnData> extends UnInstance<T, D> {
  create: (config?: UnConfig<T, D>) => UnInstance<T, D>;
  Un: typeof Un;
  CanceledError: typeof UnCanceledError<T, D>;
  CancelToken: UnCancelTokenStatic<T, D>;
  isCancel: (value: any) => value is UnCancel;
  VERSION: string;
  UnError: typeof UnError;
  isUnError: <T = any, D = any>(value: any) => value is UnError<T, D>;
  all: (values: Array<T | Promise<T>>) => Promise<T[]>;
  mergeConfig: typeof mergeConfig;
  HttpStatusCode: typeof HttpStatusCode;
}
declare const un: UnStatic<UnData, UnData>;
//#endregion
export { HttpStatusCode, Un, UnAdapter, UnCancel, UnCancelStatic, UnCancelToken, UnCancelTokenListener, UnCancelTokenSource, UnCancelTokenStatic, UnCanceledError, UnCanceler, UnConfig, UnData, UnDataType, UnError, UnFile, UnFileType, UnGenericAbortSignal, UnHeaders, UnInstance, UnInterceptorManager, UnInterceptorManagerHandler, UnInterceptorManagerHandlerFulfilled, UnInterceptorManagerHandlerRejected, UnInterceptorOptions, UnMethod, UnOnProgress, UnParams, UnParamsSerializer, UnProfile, UnPromise, UnResponse, UnResponseType, UnStatic, UnTask, UnValidateStatus, adapters, buildDownloadConfig, buildFullPath, buildRequestConfig, buildUploadConfig, buildUrl, combineUrls, defaults, dispatchRequest, downloadAdapter, extend, forEach, isAbsoluteUrl, isUnCancel, isUnError, mergeConfig, requestAdapter, settle, un, uploadAdapter };