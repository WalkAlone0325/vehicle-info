{"version":3,"file":"hex.js","sources":["uni_modules/jsencrypt/lib/lib/asn1js/hex.js"],"sourcesContent":["// Hex JavaScript decoder\n// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\nvar decoder;\nexport var Hex = {\n    decode: function (a) {\n        var i;\n        if (decoder === undefined) {\n            var hex = \"0123456789ABCDEF\";\n            var ignore = \" \\f\\n\\r\\t\\u00A0\\u2028\\u2029\";\n            decoder = {};\n            for (i = 0; i < 16; ++i) {\n                decoder[hex.charAt(i)] = i;\n            }\n            hex = hex.toLowerCase();\n            for (i = 10; i < 16; ++i) {\n                decoder[hex.charAt(i)] = i;\n            }\n            for (i = 0; i < ignore.length; ++i) {\n                decoder[ignore.charAt(i)] = -1;\n            }\n        }\n        var out = [];\n        var bits = 0;\n        var char_count = 0;\n        for (i = 0; i < a.length; ++i) {\n            var c = a.charAt(i);\n            if (c == \"=\") {\n                break;\n            }\n            c = decoder[c];\n            if (c == -1) {\n                continue;\n            }\n            if (c === undefined) {\n                throw new Error(\"Illegal character at offset \" + i);\n            }\n            bits |= c;\n            if (++char_count >= 2) {\n                out[out.length] = bits;\n                bits = 0;\n                char_count = 0;\n            }\n            else {\n                bits <<= 4;\n            }\n        }\n        if (char_count) {\n            throw new Error(\"Hex encoding incomplete: 4 bits missing\");\n        }\n        return out;\n    }\n};\n"],"names":[],"mappings":";AAcA,IAAI;AACM,IAAC,MAAM;AAAA,EACb,QAAQ,SAAU,GAAG;AACjB,QAAI;AACJ,QAAI,YAAY,QAAW;AACvB,UAAI,MAAM;AACV,UAAI,SAAS;AACb,gBAAU,CAAA;AACV,WAAK,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AACrB,gBAAQ,IAAI,OAAO,CAAC,CAAC,IAAI;AAAA,MAC5B;AACD,YAAM,IAAI;AACV,WAAK,IAAI,IAAI,IAAI,IAAI,EAAE,GAAG;AACtB,gBAAQ,IAAI,OAAO,CAAC,CAAC,IAAI;AAAA,MAC5B;AACD,WAAK,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AAChC,gBAAQ,OAAO,OAAO,CAAC,CAAC,IAAI;AAAA,MAC/B;AAAA,IACJ;AACD,QAAI,MAAM,CAAA;AACV,QAAI,OAAO;AACX,QAAI,aAAa;AACjB,SAAK,IAAI,GAAG,IAAI,EAAE,QAAQ,EAAE,GAAG;AAC3B,UAAI,IAAI,EAAE,OAAO,CAAC;AAClB,UAAI,KAAK,KAAK;AACV;AAAA,MACH;AACD,UAAI,QAAQ,CAAC;AACb,UAAI,KAAK,IAAI;AACT;AAAA,MACH;AACD,UAAI,MAAM,QAAW;AACjB,cAAM,IAAI,MAAM,iCAAiC,CAAC;AAAA,MACrD;AACD,cAAQ;AACR,UAAI,EAAE,cAAc,GAAG;AACnB,YAAI,IAAI,MAAM,IAAI;AAClB,eAAO;AACP,qBAAa;AAAA,MAChB,OACI;AACD,iBAAS;AAAA,MACZ;AAAA,IACJ;AACD,QAAI,YAAY;AACZ,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC5D;AACD,WAAO;AAAA,EACV;AACL;;"}