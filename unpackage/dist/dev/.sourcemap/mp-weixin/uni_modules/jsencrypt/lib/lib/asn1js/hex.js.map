{"version":3,"file":"hex.js","sources":["uni_modules/jsencrypt/lib/lib/asn1js/hex.js"],"sourcesContent":["// Hex JavaScript decoder\n// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\nvar decoder;\nexport var Hex = {\n    decode: function (a) {\n        var i;\n        if (decoder === undefined) {\n            var hex = \"0123456789ABCDEF\";\n            var ignore = \" \\f\\n\\r\\t\\u00A0\\u2028\\u2029\";\n            decoder = {};\n            for (i = 0; i < 16; ++i) {\n                decoder[hex.charAt(i)] = i;\n            }\n            hex = hex.toLowerCase();\n            for (i = 10; i < 16; ++i) {\n                decoder[hex.charAt(i)] = i;\n            }\n            for (i = 0; i < ignore.length; ++i) {\n                decoder[ignore.charAt(i)] = -1;\n            }\n        }\n        var out = [];\n        var bits = 0;\n        var char_count = 0;\n        for (i = 0; i < a.length; ++i) {\n            var c = a.charAt(i);\n            if (c == \"=\") {\n                break;\n            }\n            c = decoder[c];\n            if (c == -1) {\n                continue;\n            }\n            if (c === undefined) {\n                throw new Error(\"Illegal character at offset \" + i);\n            }\n            bits |= c;\n            if (++char_count >= 2) {\n                out[out.length] = bits;\n                bits = 0;\n                char_count = 0;\n            }\n            else {\n                bits <<= 4;\n            }\n        }\n        if (char_count) {\n            throw new Error(\"Hex encoding incomplete: 4 bits missing\");\n        }\n        return out;\n    }\n};\n"],"names":["decoder","Hex","a","i","hex","ignore","out","bits","char_count","c"],"mappings":"aAcA,IAAIA,EACOC,EAAM,CACb,OAAQ,SAAUC,EAAG,CACjB,IAAIC,EACJ,GAAIH,IAAY,OAAW,CACvB,IAAII,EAAM,mBACNC,EAAS;AAAA,kBAEb,IADAL,EAAU,CAAA,EACLG,EAAI,EAAGA,EAAI,GAAI,EAAEA,EAClBH,EAAQI,EAAI,OAAOD,CAAC,CAAC,EAAIA,EAG7B,IADAC,EAAMA,EAAI,cACLD,EAAI,GAAIA,EAAI,GAAI,EAAEA,EACnBH,EAAQI,EAAI,OAAOD,CAAC,CAAC,EAAIA,EAE7B,IAAKA,EAAI,EAAGA,EAAIE,EAAO,OAAQ,EAAEF,EAC7BH,EAAQK,EAAO,OAAOF,CAAC,CAAC,EAAI,EAEnC,CACD,IAAIG,EAAM,CAAA,EACNC,EAAO,EACPC,EAAa,EACjB,IAAKL,EAAI,EAAGA,EAAID,EAAE,OAAQ,EAAEC,EAAG,CAC3B,IAAIM,EAAIP,EAAE,OAAOC,CAAC,EAClB,GAAIM,GAAK,IACL,MAGJ,GADAA,EAAIT,EAAQS,CAAC,EACTA,GAAK,GAGT,IAAIA,IAAM,OACN,MAAM,IAAI,MAAM,+BAAiCN,CAAC,EAEtDI,GAAQE,EACJ,EAAED,GAAc,GAChBF,EAAIA,EAAI,MAAM,EAAIC,EAClBA,EAAO,EACPC,EAAa,GAGbD,IAAS,EAEhB,CACD,GAAIC,EACA,MAAM,IAAI,MAAM,yCAAyC,EAE7D,OAAOF,CACV,CACL"}