{"version":3,"file":"JSEncryptRSAKey.js","sources":["uni_modules/jsencrypt/lib/JSEncryptRSAKey.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { hex2b64 } from \"./lib/jsbn/base64\";\nimport { Hex } from \"./lib/asn1js/hex\";\nimport { Base64 } from \"./lib/asn1js/base64\";\nimport { ASN1 } from \"./lib/asn1js/asn1\";\nimport { RSAKey } from \"./lib/jsbn/rsa\";\nimport { parseBigInt } from \"./lib/jsbn/jsbn\";\nimport { KJUR } from \"./lib/jsrsasign/asn1-1.0\";\n/**\n * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.\n * This object is just a decorator for parsing the key parameter\n * @param {string|Object} key - The key in string format, or an object containing\n * the parameters needed to build a RSAKey object.\n * @constructor\n */\nvar JSEncryptRSAKey = /** @class */ (function (_super) {\n    __extends(JSEncryptRSAKey, _super);\n    function JSEncryptRSAKey(key) {\n        var _this = _super.call(this) || this;\n        // Call the super constructor.\n        //  RSAKey.call(this);\n        // If a key key was provided.\n        if (key) {\n            // If this is a string...\n            if (typeof key === \"string\") {\n                _this.parseKey(key);\n            }\n            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||\n                JSEncryptRSAKey.hasPublicKeyProperty(key)) {\n                // Set the values for the key.\n                _this.parsePropertiesFrom(key);\n            }\n        }\n        return _this;\n    }\n    /**\n     * Method to parse a pem encoded string containing both a public or private key.\n     * The method will translate the pem encoded string in a der encoded string and\n     * will parse private key and public key parameters. This method accepts public key\n     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).\n     *\n     * @todo Check how many rsa formats use the same format of pkcs #1.\n     *\n     * The format is defined as:\n     * PublicKeyInfo ::= SEQUENCE {\n     *   algorithm       AlgorithmIdentifier,\n     *   PublicKey       BIT STRING\n     * }\n     * Where AlgorithmIdentifier is:\n     * AlgorithmIdentifier ::= SEQUENCE {\n     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\n     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\n     * }\n     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\n     * RSAPublicKey ::= SEQUENCE {\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER   -- e\n     * }\n     * it's possible to examine the structure of the keys obtained from openssl using\n     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/\n     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer\n     * @private\n     */\n    JSEncryptRSAKey.prototype.parseKey = function (pem) {\n        try {\n            var modulus = 0;\n            var public_exponent = 0;\n            var reHex = /^\\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\\s*)+$/;\n            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);\n            var asn1 = ASN1.decode(der);\n            // Fixes a bug with OpenSSL 1.0+ private keys\n            if (asn1.sub.length === 3) {\n                asn1 = asn1.sub[2].sub[0];\n            }\n            if (asn1.sub.length === 9) {\n                // Parse the private key.\n                modulus = asn1.sub[1].getHexStringValue(); // bigint\n                this.n = parseBigInt(modulus, 16);\n                public_exponent = asn1.sub[2].getHexStringValue(); // int\n                this.e = parseInt(public_exponent, 16);\n                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint\n                this.d = parseBigInt(private_exponent, 16);\n                var prime1 = asn1.sub[4].getHexStringValue(); // bigint\n                this.p = parseBigInt(prime1, 16);\n                var prime2 = asn1.sub[5].getHexStringValue(); // bigint\n                this.q = parseBigInt(prime2, 16);\n                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint\n                this.dmp1 = parseBigInt(exponent1, 16);\n                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint\n                this.dmq1 = parseBigInt(exponent2, 16);\n                var coefficient = asn1.sub[8].getHexStringValue(); // bigint\n                this.coeff = parseBigInt(coefficient, 16);\n            }\n            else if (asn1.sub.length === 2) {\n                if (asn1.sub[0].sub) {\n                    // Parse ASN.1 SubjectPublicKeyInfo type as defined by X.509\n                    var bit_string = asn1.sub[1];\n                    var sequence = bit_string.sub[0];\n                    modulus = sequence.sub[0].getHexStringValue();\n                    this.n = parseBigInt(modulus, 16);\n                    public_exponent = sequence.sub[1].getHexStringValue();\n                    this.e = parseInt(public_exponent, 16);\n                }\n                else {\n                    // Parse ASN.1 RSAPublicKey type as defined by PKCS #1\n                    modulus = asn1.sub[0].getHexStringValue();\n                    this.n = parseBigInt(modulus, 16);\n                    public_exponent = asn1.sub[1].getHexStringValue();\n                    this.e = parseInt(public_exponent, 16);\n                }\n            }\n            else {\n                return false;\n            }\n            return true;\n        }\n        catch (ex) {\n            return false;\n        }\n    };\n    /**\n     * Translate rsa parameters in a hex encoded string representing the rsa key.\n     *\n     * The translation follow the ASN.1 notation :\n     * RSAPrivateKey ::= SEQUENCE {\n     *   version           Version,\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER,  -- e\n     *   privateExponent   INTEGER,  -- d\n     *   prime1            INTEGER,  -- p\n     *   prime2            INTEGER,  -- q\n     *   exponent1         INTEGER,  -- d mod (p1)\n     *   exponent2         INTEGER,  -- d mod (q-1)\n     *   coefficient       INTEGER,  -- (inverse of q) mod p\n     * }\n     * @returns {string}  DER Encoded String representing the rsa private key\n     * @private\n     */\n    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {\n        var options = {\n            array: [\n                new KJUR.asn1.DERInteger({ int: 0 }),\n                new KJUR.asn1.DERInteger({ bigint: this.n }),\n                new KJUR.asn1.DERInteger({ int: this.e }),\n                new KJUR.asn1.DERInteger({ bigint: this.d }),\n                new KJUR.asn1.DERInteger({ bigint: this.p }),\n                new KJUR.asn1.DERInteger({ bigint: this.q }),\n                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),\n                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),\n                new KJUR.asn1.DERInteger({ bigint: this.coeff }),\n            ],\n        };\n        var seq = new KJUR.asn1.DERSequence(options);\n        return seq.getEncodedHex();\n    };\n    /**\n     * base64 (pem) encoded version of the DER encoded representation\n     * @returns {string} pem encoded representation without header and footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {\n        return hex2b64(this.getPrivateBaseKey());\n    };\n    /**\n     * Translate rsa parameters in a hex encoded string representing the rsa public key.\n     * The representation follow the ASN.1 notation :\n     * PublicKeyInfo ::= SEQUENCE {\n     *   algorithm       AlgorithmIdentifier,\n     *   PublicKey       BIT STRING\n     * }\n     * Where AlgorithmIdentifier is:\n     * AlgorithmIdentifier ::= SEQUENCE {\n     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\n     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\n     * }\n     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\n     * RSAPublicKey ::= SEQUENCE {\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER   -- e\n     * }\n     * @returns {string} DER Encoded String representing the rsa public key\n     * @private\n     */\n    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {\n        var first_sequence = new KJUR.asn1.DERSequence({\n            array: [\n                new KJUR.asn1.DERObjectIdentifier({ oid: \"1.2.840.113549.1.1.1\" }),\n                new KJUR.asn1.DERNull(),\n            ],\n        });\n        var second_sequence = new KJUR.asn1.DERSequence({\n            array: [\n                new KJUR.asn1.DERInteger({ bigint: this.n }),\n                new KJUR.asn1.DERInteger({ int: this.e }),\n            ],\n        });\n        var bit_string = new KJUR.asn1.DERBitString({\n            hex: \"00\" + second_sequence.getEncodedHex(),\n        });\n        var seq = new KJUR.asn1.DERSequence({\n            array: [first_sequence, bit_string],\n        });\n        return seq.getEncodedHex();\n    };\n    /**\n     * base64 (pem) encoded version of the DER encoded representation\n     * @returns {string} pem encoded representation without header and footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {\n        return hex2b64(this.getPublicBaseKey());\n    };\n    /**\n     * wrap the string in block of width chars. The default value for rsa keys is 64\n     * characters.\n     * @param {string} str the pem encoded string without header and footer\n     * @param {Number} [width=64] - the length the string has to be wrapped at\n     * @returns {string}\n     * @private\n     */\n    JSEncryptRSAKey.wordwrap = function (str, width) {\n        width = width || 64;\n        if (!str) {\n            return str;\n        }\n        var regex = \"(.{1,\" + width + \"})( +|$\\n?)|(.{1,\" + width + \"})\";\n        return str.match(RegExp(regex, \"g\")).join(\"\\n\");\n    };\n    /**\n     * Retrieve the pem encoded private key\n     * @returns {string} the pem encoded private key with header/footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPrivateKey = function () {\n        var key = \"-----BEGIN RSA PRIVATE KEY-----\\n\";\n        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + \"\\n\";\n        key += \"-----END RSA PRIVATE KEY-----\";\n        return key;\n    };\n    /**\n     * Retrieve the pem encoded public key\n     * @returns {string} the pem encoded public key with header/footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPublicKey = function () {\n        var key = \"-----BEGIN PUBLIC KEY-----\\n\";\n        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + \"\\n\";\n        key += \"-----END PUBLIC KEY-----\";\n        return key;\n    };\n    /**\n     * Check if the object contains the necessary parameters to populate the rsa modulus\n     * and public exponent parameters.\n     * @param {Object} [obj={}] - An object that may contain the two public key\n     * parameters\n     * @returns {boolean} true if the object contains both the modulus and the public exponent\n     * properties (n and e)\n     * @todo check for types of n and e. N should be a parseable bigInt object, E should\n     * be a parseable integer number\n     * @private\n     */\n    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {\n        obj = obj || {};\n        return obj.hasOwnProperty(\"n\") && obj.hasOwnProperty(\"e\");\n    };\n    /**\n     * Check if the object contains ALL the parameters of an RSA key.\n     * @param {Object} [obj={}] - An object that may contain nine rsa key\n     * parameters\n     * @returns {boolean} true if the object contains all the parameters needed\n     * @todo check for types of the parameters all the parameters but the public exponent\n     * should be parseable bigint objects, the public exponent should be a parseable integer number\n     * @private\n     */\n    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {\n        obj = obj || {};\n        return (obj.hasOwnProperty(\"n\") &&\n            obj.hasOwnProperty(\"e\") &&\n            obj.hasOwnProperty(\"d\") &&\n            obj.hasOwnProperty(\"p\") &&\n            obj.hasOwnProperty(\"q\") &&\n            obj.hasOwnProperty(\"dmp1\") &&\n            obj.hasOwnProperty(\"dmq1\") &&\n            obj.hasOwnProperty(\"coeff\"));\n    };\n    /**\n     * Parse the properties of obj in the current rsa object. Obj should AT LEAST\n     * include the modulus and public exponent (n, e) parameters.\n     * @param {Object} obj - the object containing rsa parameters\n     * @private\n     */\n    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {\n        this.n = obj.n;\n        this.e = obj.e;\n        if (obj.hasOwnProperty(\"d\")) {\n            this.d = obj.d;\n            this.p = obj.p;\n            this.q = obj.q;\n            this.dmp1 = obj.dmp1;\n            this.dmq1 = obj.dmq1;\n            this.coeff = obj.coeff;\n        }\n    };\n    return JSEncryptRSAKey;\n}(RSAKey));\nexport { JSEncryptRSAKey };\n"],"names":["d","b","JSEncryptRSAKey","Hex","Base64","ASN1","parseBigInt","KJUR","hex2b64","RSAKey"],"mappings":";;;;;;;;AAAA,IAAI,YAAyC,2BAAY;AACrD,MAAI,gBAAgB,SAAU,GAAG,GAAG;AAChC,oBAAgB,OAAO,kBAClB,EAAE,WAAW,CAAA,eAAgB,SAAS,SAAUA,IAAGC,IAAG;AAAE,MAAAD,GAAE,YAAYC;AAAA,IAAE,KACzE,SAAUD,IAAGC,IAAG;AAAE,eAAS,KAAKA;AAAG,YAAI,OAAO,UAAU,eAAe,KAAKA,IAAG,CAAC;AAAG,UAAAD,GAAE,CAAC,IAAIC,GAAE,CAAC;AAAA;AACjG,WAAO,cAAc,GAAG,CAAC;AAAA,EACjC;AACI,SAAO,SAAU,GAAG,GAAG;AACnB,QAAI,OAAO,MAAM,cAAc,MAAM;AACjC,YAAM,IAAI,UAAU,yBAAyB,OAAO,CAAC,IAAI,+BAA+B;AAC5F,kBAAc,GAAG,CAAC;AAClB,aAAS,KAAK;AAAE,WAAK,cAAc;AAAA,IAAI;AACvC,MAAE,YAAY,MAAM,OAAO,OAAO,OAAO,CAAC,KAAK,GAAG,YAAY,EAAE,WAAW,IAAI,GAAI;AAAA,EAC3F;AACA;AAeG,IAAC;AAAA;AAAA,EAAiC,SAAU,QAAQ;AACnD,cAAUC,kBAAiB,MAAM;AACjC,aAASA,iBAAgB,KAAK;AAC1B,UAAI,QAAQ,OAAO,KAAK,IAAI,KAAK;AAIjC,UAAI,KAAK;AAEL,YAAI,OAAO,QAAQ,UAAU;AACzB,gBAAM,SAAS,GAAG;AAAA,QACrB,WACQA,iBAAgB,sBAAsB,GAAG,KAC9CA,iBAAgB,qBAAqB,GAAG,GAAG;AAE3C,gBAAM,oBAAoB,GAAG;AAAA,QAChC;AAAA,MACJ;AACD,aAAO;AAAA,IACV;AA6BD,IAAAA,iBAAgB,UAAU,WAAW,SAAU,KAAK;AAChD,UAAI;AACA,YAAI,UAAU;AACd,YAAI,kBAAkB;AACtB,YAAI,QAAQ;AACZ,YAAI,MAAM,MAAM,KAAK,GAAG,IAAIC,yCAAAA,IAAI,OAAO,GAAG,IAAIC,4CAAAA,OAAO,QAAQ,GAAG;AAChE,YAAI,OAAOC,0CAAAA,KAAK,OAAO,GAAG;AAE1B,YAAI,KAAK,IAAI,WAAW,GAAG;AACvB,iBAAO,KAAK,IAAI,CAAC,EAAE,IAAI,CAAC;AAAA,QAC3B;AACD,YAAI,KAAK,IAAI,WAAW,GAAG;AAEvB,oBAAU,KAAK,IAAI,CAAC,EAAE,kBAAiB;AACvC,eAAK,IAAIC,wCAAAA,YAAY,SAAS,EAAE;AAChC,4BAAkB,KAAK,IAAI,CAAC,EAAE,kBAAiB;AAC/C,eAAK,IAAI,SAAS,iBAAiB,EAAE;AACrC,cAAI,mBAAmB,KAAK,IAAI,CAAC,EAAE,kBAAiB;AACpD,eAAK,IAAIA,wCAAAA,YAAY,kBAAkB,EAAE;AACzC,cAAI,SAAS,KAAK,IAAI,CAAC,EAAE,kBAAiB;AAC1C,eAAK,IAAIA,wCAAAA,YAAY,QAAQ,EAAE;AAC/B,cAAI,SAAS,KAAK,IAAI,CAAC,EAAE,kBAAiB;AAC1C,eAAK,IAAIA,wCAAAA,YAAY,QAAQ,EAAE;AAC/B,cAAI,YAAY,KAAK,IAAI,CAAC,EAAE,kBAAiB;AAC7C,eAAK,OAAOA,wCAAAA,YAAY,WAAW,EAAE;AACrC,cAAI,YAAY,KAAK,IAAI,CAAC,EAAE,kBAAiB;AAC7C,eAAK,OAAOA,wCAAAA,YAAY,WAAW,EAAE;AACrC,cAAI,cAAc,KAAK,IAAI,CAAC,EAAE,kBAAiB;AAC/C,eAAK,QAAQA,wCAAAA,YAAY,aAAa,EAAE;AAAA,QAC3C,WACQ,KAAK,IAAI,WAAW,GAAG;AAC5B,cAAI,KAAK,IAAI,CAAC,EAAE,KAAK;AAEjB,gBAAI,aAAa,KAAK,IAAI,CAAC;AAC3B,gBAAI,WAAW,WAAW,IAAI,CAAC;AAC/B,sBAAU,SAAS,IAAI,CAAC,EAAE,kBAAiB;AAC3C,iBAAK,IAAIA,wCAAAA,YAAY,SAAS,EAAE;AAChC,8BAAkB,SAAS,IAAI,CAAC,EAAE,kBAAiB;AACnD,iBAAK,IAAI,SAAS,iBAAiB,EAAE;AAAA,UACxC,OACI;AAED,sBAAU,KAAK,IAAI,CAAC,EAAE,kBAAiB;AACvC,iBAAK,IAAIA,wCAAAA,YAAY,SAAS,EAAE;AAChC,8BAAkB,KAAK,IAAI,CAAC,EAAE,kBAAiB;AAC/C,iBAAK,IAAI,SAAS,iBAAiB,EAAE;AAAA,UACxC;AAAA,QACJ,OACI;AACD,iBAAO;AAAA,QACV;AACD,eAAO;AAAA,MACV,SACM,IAAI;AACP,eAAO;AAAA,MACV;AAAA,IACT;AAmBI,IAAAJ,iBAAgB,UAAU,oBAAoB,WAAY;AACtD,UAAI,UAAU;AAAA,QACV,OAAO;AAAA,UACH,IAAIK,gDAAAA,KAAK,KAAK,WAAW,EAAE,KAAK,EAAC,CAAE;AAAA,UACnC,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,QAAQ,KAAK,GAAG;AAAA,UAC3C,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,KAAK,KAAK,GAAG;AAAA,UACxC,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,QAAQ,KAAK,GAAG;AAAA,UAC3C,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,QAAQ,KAAK,GAAG;AAAA,UAC3C,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,QAAQ,KAAK,GAAG;AAAA,UAC3C,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,QAAQ,KAAK,MAAM;AAAA,UAC9C,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,QAAQ,KAAK,MAAM;AAAA,UAC9C,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,QAAQ,KAAK,OAAO;AAAA,QAClD;AAAA,MACb;AACQ,UAAI,MAAM,IAAIA,gDAAI,KAAC,KAAK,YAAY,OAAO;AAC3C,aAAO,IAAI;IACnB;AAMI,IAAAL,iBAAgB,UAAU,uBAAuB,WAAY;AACzD,aAAOM,kDAAQ,KAAK,kBAAiB,CAAE;AAAA,IAC/C;AAqBI,IAAAN,iBAAgB,UAAU,mBAAmB,WAAY;AACrD,UAAI,iBAAiB,IAAIK,qDAAK,KAAK,YAAY;AAAA,QAC3C,OAAO;AAAA,UACH,IAAIA,gDAAAA,KAAK,KAAK,oBAAoB,EAAE,KAAK,uBAAsB,CAAE;AAAA,UACjE,IAAIA,gDAAI,KAAC,KAAK,QAAS;AAAA,QAC1B;AAAA,MACb,CAAS;AACD,UAAI,kBAAkB,IAAIA,qDAAK,KAAK,YAAY;AAAA,QAC5C,OAAO;AAAA,UACH,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,QAAQ,KAAK,GAAG;AAAA,UAC3C,IAAIA,gDAAAA,KAAK,KAAK,WAAW,EAAE,KAAK,KAAK,GAAG;AAAA,QAC3C;AAAA,MACb,CAAS;AACD,UAAI,aAAa,IAAIA,qDAAK,KAAK,aAAa;AAAA,QACxC,KAAK,OAAO,gBAAgB,cAAe;AAAA,MACvD,CAAS;AACD,UAAI,MAAM,IAAIA,qDAAK,KAAK,YAAY;AAAA,QAChC,OAAO,CAAC,gBAAgB,UAAU;AAAA,MAC9C,CAAS;AACD,aAAO,IAAI;IACnB;AAMI,IAAAL,iBAAgB,UAAU,sBAAsB,WAAY;AACxD,aAAOM,kDAAQ,KAAK,iBAAgB,CAAE;AAAA,IAC9C;AASI,IAAAN,iBAAgB,WAAW,SAAU,KAAK,OAAO;AAC7C,cAAQ,SAAS;AACjB,UAAI,CAAC,KAAK;AACN,eAAO;AAAA,MACV;AACD,UAAI,QAAQ,UAAU,QAAQ,sBAAsB,QAAQ;AAC5D,aAAO,IAAI,MAAM,OAAO,OAAO,GAAG,CAAC,EAAE,KAAK,IAAI;AAAA,IACtD;AAMI,IAAAA,iBAAgB,UAAU,gBAAgB,WAAY;AAClD,UAAI,MAAM;AACV,aAAOA,iBAAgB,SAAS,KAAK,qBAAoB,CAAE,IAAI;AAC/D,aAAO;AACP,aAAO;AAAA,IACf;AAMI,IAAAA,iBAAgB,UAAU,eAAe,WAAY;AACjD,UAAI,MAAM;AACV,aAAOA,iBAAgB,SAAS,KAAK,oBAAmB,CAAE,IAAI;AAC9D,aAAO;AACP,aAAO;AAAA,IACf;AAYI,IAAAA,iBAAgB,uBAAuB,SAAU,KAAK;AAClD,YAAM,OAAO;AACb,aAAO,IAAI,eAAe,GAAG,KAAK,IAAI,eAAe,GAAG;AAAA,IAChE;AAUI,IAAAA,iBAAgB,wBAAwB,SAAU,KAAK;AACnD,YAAM,OAAO;AACb,aAAQ,IAAI,eAAe,GAAG,KAC1B,IAAI,eAAe,GAAG,KACtB,IAAI,eAAe,GAAG,KACtB,IAAI,eAAe,GAAG,KACtB,IAAI,eAAe,GAAG,KACtB,IAAI,eAAe,MAAM,KACzB,IAAI,eAAe,MAAM,KACzB,IAAI,eAAe,OAAO;AAAA,IACtC;AAOI,IAAAA,iBAAgB,UAAU,sBAAsB,SAAU,KAAK;AAC3D,WAAK,IAAI,IAAI;AACb,WAAK,IAAI,IAAI;AACb,UAAI,IAAI,eAAe,GAAG,GAAG;AACzB,aAAK,IAAI,IAAI;AACb,aAAK,IAAI,IAAI;AACb,aAAK,IAAI,IAAI;AACb,aAAK,OAAO,IAAI;AAChB,aAAK,OAAO,IAAI;AAChB,aAAK,QAAQ,IAAI;AAAA,MACpB;AAAA,IACT;AACI,WAAOA;AAAA,EACX,EAAEO,6CAAM;AAAA;;"}