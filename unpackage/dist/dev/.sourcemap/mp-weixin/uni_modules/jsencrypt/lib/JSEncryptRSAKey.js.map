{"version":3,"file":"JSEncryptRSAKey.js","sources":["uni_modules/jsencrypt/lib/JSEncryptRSAKey.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { hex2b64 } from \"./lib/jsbn/base64\";\nimport { Hex } from \"./lib/asn1js/hex\";\nimport { Base64 } from \"./lib/asn1js/base64\";\nimport { ASN1 } from \"./lib/asn1js/asn1\";\nimport { RSAKey } from \"./lib/jsbn/rsa\";\nimport { parseBigInt } from \"./lib/jsbn/jsbn\";\nimport { KJUR } from \"./lib/jsrsasign/asn1-1.0\";\n/**\n * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.\n * This object is just a decorator for parsing the key parameter\n * @param {string|Object} key - The key in string format, or an object containing\n * the parameters needed to build a RSAKey object.\n * @constructor\n */\nvar JSEncryptRSAKey = /** @class */ (function (_super) {\n    __extends(JSEncryptRSAKey, _super);\n    function JSEncryptRSAKey(key) {\n        var _this = _super.call(this) || this;\n        // Call the super constructor.\n        //  RSAKey.call(this);\n        // If a key key was provided.\n        if (key) {\n            // If this is a string...\n            if (typeof key === \"string\") {\n                _this.parseKey(key);\n            }\n            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||\n                JSEncryptRSAKey.hasPublicKeyProperty(key)) {\n                // Set the values for the key.\n                _this.parsePropertiesFrom(key);\n            }\n        }\n        return _this;\n    }\n    /**\n     * Method to parse a pem encoded string containing both a public or private key.\n     * The method will translate the pem encoded string in a der encoded string and\n     * will parse private key and public key parameters. This method accepts public key\n     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).\n     *\n     * @todo Check how many rsa formats use the same format of pkcs #1.\n     *\n     * The format is defined as:\n     * PublicKeyInfo ::= SEQUENCE {\n     *   algorithm       AlgorithmIdentifier,\n     *   PublicKey       BIT STRING\n     * }\n     * Where AlgorithmIdentifier is:\n     * AlgorithmIdentifier ::= SEQUENCE {\n     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\n     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\n     * }\n     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\n     * RSAPublicKey ::= SEQUENCE {\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER   -- e\n     * }\n     * it's possible to examine the structure of the keys obtained from openssl using\n     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/\n     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer\n     * @private\n     */\n    JSEncryptRSAKey.prototype.parseKey = function (pem) {\n        try {\n            var modulus = 0;\n            var public_exponent = 0;\n            var reHex = /^\\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\\s*)+$/;\n            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);\n            var asn1 = ASN1.decode(der);\n            // Fixes a bug with OpenSSL 1.0+ private keys\n            if (asn1.sub.length === 3) {\n                asn1 = asn1.sub[2].sub[0];\n            }\n            if (asn1.sub.length === 9) {\n                // Parse the private key.\n                modulus = asn1.sub[1].getHexStringValue(); // bigint\n                this.n = parseBigInt(modulus, 16);\n                public_exponent = asn1.sub[2].getHexStringValue(); // int\n                this.e = parseInt(public_exponent, 16);\n                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint\n                this.d = parseBigInt(private_exponent, 16);\n                var prime1 = asn1.sub[4].getHexStringValue(); // bigint\n                this.p = parseBigInt(prime1, 16);\n                var prime2 = asn1.sub[5].getHexStringValue(); // bigint\n                this.q = parseBigInt(prime2, 16);\n                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint\n                this.dmp1 = parseBigInt(exponent1, 16);\n                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint\n                this.dmq1 = parseBigInt(exponent2, 16);\n                var coefficient = asn1.sub[8].getHexStringValue(); // bigint\n                this.coeff = parseBigInt(coefficient, 16);\n            }\n            else if (asn1.sub.length === 2) {\n                if (asn1.sub[0].sub) {\n                    // Parse ASN.1 SubjectPublicKeyInfo type as defined by X.509\n                    var bit_string = asn1.sub[1];\n                    var sequence = bit_string.sub[0];\n                    modulus = sequence.sub[0].getHexStringValue();\n                    this.n = parseBigInt(modulus, 16);\n                    public_exponent = sequence.sub[1].getHexStringValue();\n                    this.e = parseInt(public_exponent, 16);\n                }\n                else {\n                    // Parse ASN.1 RSAPublicKey type as defined by PKCS #1\n                    modulus = asn1.sub[0].getHexStringValue();\n                    this.n = parseBigInt(modulus, 16);\n                    public_exponent = asn1.sub[1].getHexStringValue();\n                    this.e = parseInt(public_exponent, 16);\n                }\n            }\n            else {\n                return false;\n            }\n            return true;\n        }\n        catch (ex) {\n            return false;\n        }\n    };\n    /**\n     * Translate rsa parameters in a hex encoded string representing the rsa key.\n     *\n     * The translation follow the ASN.1 notation :\n     * RSAPrivateKey ::= SEQUENCE {\n     *   version           Version,\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER,  -- e\n     *   privateExponent   INTEGER,  -- d\n     *   prime1            INTEGER,  -- p\n     *   prime2            INTEGER,  -- q\n     *   exponent1         INTEGER,  -- d mod (p1)\n     *   exponent2         INTEGER,  -- d mod (q-1)\n     *   coefficient       INTEGER,  -- (inverse of q) mod p\n     * }\n     * @returns {string}  DER Encoded String representing the rsa private key\n     * @private\n     */\n    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {\n        var options = {\n            array: [\n                new KJUR.asn1.DERInteger({ int: 0 }),\n                new KJUR.asn1.DERInteger({ bigint: this.n }),\n                new KJUR.asn1.DERInteger({ int: this.e }),\n                new KJUR.asn1.DERInteger({ bigint: this.d }),\n                new KJUR.asn1.DERInteger({ bigint: this.p }),\n                new KJUR.asn1.DERInteger({ bigint: this.q }),\n                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),\n                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),\n                new KJUR.asn1.DERInteger({ bigint: this.coeff }),\n            ],\n        };\n        var seq = new KJUR.asn1.DERSequence(options);\n        return seq.getEncodedHex();\n    };\n    /**\n     * base64 (pem) encoded version of the DER encoded representation\n     * @returns {string} pem encoded representation without header and footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {\n        return hex2b64(this.getPrivateBaseKey());\n    };\n    /**\n     * Translate rsa parameters in a hex encoded string representing the rsa public key.\n     * The representation follow the ASN.1 notation :\n     * PublicKeyInfo ::= SEQUENCE {\n     *   algorithm       AlgorithmIdentifier,\n     *   PublicKey       BIT STRING\n     * }\n     * Where AlgorithmIdentifier is:\n     * AlgorithmIdentifier ::= SEQUENCE {\n     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\n     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\n     * }\n     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\n     * RSAPublicKey ::= SEQUENCE {\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER   -- e\n     * }\n     * @returns {string} DER Encoded String representing the rsa public key\n     * @private\n     */\n    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {\n        var first_sequence = new KJUR.asn1.DERSequence({\n            array: [\n                new KJUR.asn1.DERObjectIdentifier({ oid: \"1.2.840.113549.1.1.1\" }),\n                new KJUR.asn1.DERNull(),\n            ],\n        });\n        var second_sequence = new KJUR.asn1.DERSequence({\n            array: [\n                new KJUR.asn1.DERInteger({ bigint: this.n }),\n                new KJUR.asn1.DERInteger({ int: this.e }),\n            ],\n        });\n        var bit_string = new KJUR.asn1.DERBitString({\n            hex: \"00\" + second_sequence.getEncodedHex(),\n        });\n        var seq = new KJUR.asn1.DERSequence({\n            array: [first_sequence, bit_string],\n        });\n        return seq.getEncodedHex();\n    };\n    /**\n     * base64 (pem) encoded version of the DER encoded representation\n     * @returns {string} pem encoded representation without header and footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {\n        return hex2b64(this.getPublicBaseKey());\n    };\n    /**\n     * wrap the string in block of width chars. The default value for rsa keys is 64\n     * characters.\n     * @param {string} str the pem encoded string without header and footer\n     * @param {Number} [width=64] - the length the string has to be wrapped at\n     * @returns {string}\n     * @private\n     */\n    JSEncryptRSAKey.wordwrap = function (str, width) {\n        width = width || 64;\n        if (!str) {\n            return str;\n        }\n        var regex = \"(.{1,\" + width + \"})( +|$\\n?)|(.{1,\" + width + \"})\";\n        return str.match(RegExp(regex, \"g\")).join(\"\\n\");\n    };\n    /**\n     * Retrieve the pem encoded private key\n     * @returns {string} the pem encoded private key with header/footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPrivateKey = function () {\n        var key = \"-----BEGIN RSA PRIVATE KEY-----\\n\";\n        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + \"\\n\";\n        key += \"-----END RSA PRIVATE KEY-----\";\n        return key;\n    };\n    /**\n     * Retrieve the pem encoded public key\n     * @returns {string} the pem encoded public key with header/footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPublicKey = function () {\n        var key = \"-----BEGIN PUBLIC KEY-----\\n\";\n        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + \"\\n\";\n        key += \"-----END PUBLIC KEY-----\";\n        return key;\n    };\n    /**\n     * Check if the object contains the necessary parameters to populate the rsa modulus\n     * and public exponent parameters.\n     * @param {Object} [obj={}] - An object that may contain the two public key\n     * parameters\n     * @returns {boolean} true if the object contains both the modulus and the public exponent\n     * properties (n and e)\n     * @todo check for types of n and e. N should be a parseable bigInt object, E should\n     * be a parseable integer number\n     * @private\n     */\n    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {\n        obj = obj || {};\n        return obj.hasOwnProperty(\"n\") && obj.hasOwnProperty(\"e\");\n    };\n    /**\n     * Check if the object contains ALL the parameters of an RSA key.\n     * @param {Object} [obj={}] - An object that may contain nine rsa key\n     * parameters\n     * @returns {boolean} true if the object contains all the parameters needed\n     * @todo check for types of the parameters all the parameters but the public exponent\n     * should be parseable bigint objects, the public exponent should be a parseable integer number\n     * @private\n     */\n    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {\n        obj = obj || {};\n        return (obj.hasOwnProperty(\"n\") &&\n            obj.hasOwnProperty(\"e\") &&\n            obj.hasOwnProperty(\"d\") &&\n            obj.hasOwnProperty(\"p\") &&\n            obj.hasOwnProperty(\"q\") &&\n            obj.hasOwnProperty(\"dmp1\") &&\n            obj.hasOwnProperty(\"dmq1\") &&\n            obj.hasOwnProperty(\"coeff\"));\n    };\n    /**\n     * Parse the properties of obj in the current rsa object. Obj should AT LEAST\n     * include the modulus and public exponent (n, e) parameters.\n     * @param {Object} obj - the object containing rsa parameters\n     * @private\n     */\n    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {\n        this.n = obj.n;\n        this.e = obj.e;\n        if (obj.hasOwnProperty(\"d\")) {\n            this.d = obj.d;\n            this.p = obj.p;\n            this.q = obj.q;\n            this.dmp1 = obj.dmp1;\n            this.dmq1 = obj.dmq1;\n            this.coeff = obj.coeff;\n        }\n    };\n    return JSEncryptRSAKey;\n}(RSAKey));\nexport { JSEncryptRSAKey };\n"],"names":["__extends","extendStatics","d","b","p","__","JSEncryptRSAKey","_super","key","_this","pem","modulus","public_exponent","reHex","der","Hex","Base64","asn1","ASN1","parseBigInt","private_exponent","prime1","prime2","exponent1","exponent2","coefficient","bit_string","sequence","options","KJUR","seq","hex2b64","first_sequence","second_sequence","str","width","regex","obj","RSAKey"],"mappings":"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"}